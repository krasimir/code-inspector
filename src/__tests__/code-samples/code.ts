export default from "bar";
export const a = {};
const b = 42;
export default b;

function f(j, k){
  "use strict".foo;
}

for(var i=0; i<10; i++) {
  console.log(i);
}
for(var c in d) {
  console.log(a);
}

(function (w) {
  return function fn(op) {} /42/i
})(window)

const Comp = function () {
  return (
    <AnotherComponent>
      {
        () => <p>Hello</p>
      }
      <a b={" "} c=" " d="&amp;" e="&ampr;" />
      <>
        Hello
      </>
      {}
    </AnotherComponent>
  )
}

if (a === 'foo' && x || y || z) {
  console.log('a is foo');
}

const cxc = new CCC('foo', 'bar');
const nnn = null;

var obob = {
  foo: 'bar',
  mmm(a) {
    return a + 1;
  }
}
const { foo, mmm } = obob;

function * TTT() {
  if ((yield select(mySelector))) {
    return 'aaa';
  }
}

class A {
  #a: string;
  #b?;
  #c?: number;
  #d!;
  #e!: boolean;
}

const eee = /foo bar/g;

function MyFunc(a, b, ...re) {
  return {
    ...re
  }
}

function aIO({ b, ...c }) {}

const moo = (a(), b());

class M extends TT {
  constructor() {
    super('aa')
  }
}

switch(SOME) {
  case 'foo': console.log('aaa'); break;
}

function UI(a: any):void {}
var tsa: number[] = [];

tsa(a as Object)

let appp: any;
let un: unknown;
let bnnnn: boolean;
let ne: never;
let nul: null;
let num: number;
let o: object;
let st: string;
let sy: symbol;
let u: undefined;
let v: void;
let n: bigint;

interface I {
  (x: number, b: string): void;
}

let x: number extends string ? boolean : null;

interface II {
  new (x: number): void;
}

declare function f(a:number): void;
declare function f<T>(): T;

class C {
  static f(a:string, b: string);
  public static f(a:string, b: string);
  protected static f(a:string, b: string);
  private static f(a:string, b: string);
}

const enum Foo1 {
  "OP"= "HOP"
}

enum A90 {
  a,
  "r"
}

export = f;

(class C implements X.Y<T> {});

import xxff = require ("asdfasdf");

type MyType = ({ theme }: any) => any;

let opi: typeof import('./x');

class FF2C {
  [x: string]: any;
  readonly [x: string]: any;
}

let x90: T[K];

type Element<T> = T extends (infer U)[] ? U : T;

type F10 = x90 & Element;

type Foo12 = false;

let map1: { [P in string]: number; };

interface I892 {
  [Symbol.iterator](): void;
  [Symbol.iterator]?(): number;
}

declare module "m" {}

export as namespace A;

x!;

let go22: [string, number?, (string | number)?]

class C221 {
  constructor(
      public y?: number = 0
  ) {}
}

interface Comma { x: number, y: number }

let x123: [string, ...string[],]

class F3oo {
  isBar(): this is string {
  }
  isBaz = (): this is string => {
  }
}

const s = {
  set m(this: { x: number }, value) {}
};

let x76: keyof T;